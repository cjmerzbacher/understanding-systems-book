

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stochastic Modeling &#8212; My sample book</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-dropdown.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">My sample book</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to your Jupyter Book
  </a>
 </li>
</ul>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="differentialequations.html">
   Differential Equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="differentialequations.html#to-do">
   TO DO
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="annotatinggraphs.html">
   Annotating Graphs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="clusteringgraphs.html">
   Clustering Graphs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="regression.html">
   Regression
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/docs/stochasticmodeling.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#figure-with-equations-including-both">
   Figure with equations including both
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#works-cited">
   Works Cited
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="stochastic-modeling">
<h1>Stochastic Modeling<a class="headerlink" href="#stochastic-modeling" title="Permalink to this headline">Â¶</a></h1>
<p>One of the important assumptions of the differential equation models considered previously is a continuous distribution of the proteins or molecules of interest. In reality, cells contain only a finite (and usually quite small) number of a particular molecule. In some cases, we do not care to model individual cells: we may be able to consider a population of cells as a single unit, for instance in the case of a bulk bioreactor. However, for other applications we may want to examine gene expression in individual cells. Single-cell analysis is a growing family of techniques that allows scientists to study heterogeneous populations of cells and understand complex intercellular dynamics.</p>
<p><img alt="Proteins glowing in a cell" src="../_images/protein_cell_cycle.gif" /></p>
<p>To more adequately describe these <strong>low-copy number dynamics</strong>, we will use stochastic modeling. The system is quite similar to the one considered in the differential equations section <span class="xref myst">here</span>:</p>
<p><img alt="Basic Model" src="../_images/equations_model.png" /></p>
<p>However, instead of using deterministic equations, we will model the probability of making a protein or mRNA molecule. The number of mRNA per cell cycle is distributed in a Poisson distribution, like many biological phenomena:</p>
<center>
<p><span class="math notranslate nohighlight">\(p(N) = \frac{\lambda^n}{n!}e^{-\lambda}\)</span></p>
</center> 
<p>A Poisson distribution is a distribution that models the number of events occuring within a given time interval (in this case, the length of a single cell cycle). <span class="math notranslate nohighlight">\(\lambda\)</span> is the shape parameter, which indicates the average number of events in the time interval.</p>
<p>The mean number of proteins, on the other hand, is dependent on the number of mRNA molecules. For each time step, the mRNA molecule can either degrade or replicate into a protein:</p>
<p><img alt="Figure with mRNA replication/degradation loop" src="../_images/mrna_degradation_loop.png" /></p>
<p>Given a probability that an mRNA produces a protein <span class="math notranslate nohighlight">\(p\)</span>, the probability of producing 0, 1, 2, or N proteins is:</p>
<center>
<p><span class="math notranslate nohighlight">\(P(0) = 1 - p\)</span>
<span class="math notranslate nohighlight">\(P(1) = p(1 - p)\)</span>
<span class="math notranslate nohighlight">\(P(2) = p^2(1 - p)\)</span>
<span class="math notranslate nohighlight">\(P(N) = p^N(1 - p)\)</span></p>
</center> 
<p>This mechanism results in a geometric distribution. Note that the mean number of proteins is actually not the most likely number in the cell.</p>
<p><img alt="Summary figure of poisson/geometric distributions" src="../_images/distributions.png" /></p>
<p>Itâs important to note that while the number of protein/mRNA molecules in a cell is random, the <em>distribution</em> of these molecules is not. Therefore, we will model the deterministic way these probability distributions evolve over time in our model. To find the steady-state distributions, we will use the <strong>Master equation</strong>. Each state (number of molecules) is modeled with a separate deterministic equation. Examining the case of <span class="math notranslate nohighlight">\(n\)</span> mRNA molecules:</p>
<center>
<p><span class="math notranslate nohighlight">\(m_{n-1} \xrightleftharpoons[g_{n}]{f_{n-1}} m_n \xrightleftharpoons[g_{n+1}]{f_n} m_{n+1}\)</span></p>
<p><span class="math notranslate nohighlight">\( \frac{\delta P(m_n)}{\delta t} = f_{n-1}m_{n-1} + g_{n+1}m_{n+1} - (f_n + g_n) m\)</span></p>
</center> 
<p>For the simple model we established, the only components of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are constant degradation and production. Therefore, <span class="math notranslate nohighlight">\(f_n\)</span> is just <span class="math notranslate nohighlight">\(S_m\)</span> and <span class="math notranslate nohighlight">\(g_m\)</span> is <span class="math notranslate nohighlight">\(d_{m} n\)</span>. The number of mRNA in a cell <span class="math notranslate nohighlight">\(m_n\)</span> is a Poisson distribution:</p>
<center>
<p><span class="math notranslate nohighlight">\(m_n = \frac{S_m}{d_m}\frac{1}{n!}m_o \approx \frac{\lambda^n}{n!}e^{-\lambda}\)</span></p>
</center> 
<p>We can make similar equations for the protein distribution; however, we use a geometric distribution rather than a Poisson distribution.</p>
<p>A more complex model includes both mRNA and protein states. If <span class="math notranslate nohighlight">\(m\)</span> is the number of mRNA and <span class="math notranslate nohighlight">\(n\)</span> is the number of proteins, the possible states can be shown as a 2-dimensional matrix:</p>
<div class="section" id="figure-with-equations-including-both">
<h2>Figure with equations including both<a class="headerlink" href="#figure-with-equations-including-both" title="Permalink to this headline">Â¶</a></h2>
<p>From the Master equation, we will have an infinite set of differential equations. To solve these equations, we can run simulations with many mRNA and protein initial conditions and plot the trajectories. Examining our simple model, we can build a Master Equation simulator in Python. First, we write functions to describe <span class="math notranslate nohighlight">\(m_n\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, and <span class="math notranslate nohighlight">\(P(m_n)\)</span>. The functions for <span class="math notranslate nohighlight">\(m_n\)</span> and <span class="math notranslate nohighlight">\(g\)</span> take the current number of mRNA molecules in the cell and return the function value.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_m</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mo</span><span class="p">):</span>
    <span class="n">mn</span> <span class="o">=</span> <span class="n">mo</span><span class="o">*</span><span class="n">Sm</span><span class="o">/</span><span class="n">dm</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mn</span>

<span class="k">def</span> <span class="nf">get_g</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">dm</span>
</pre></div>
</div>
<p>The function to get <span class="math notranslate nohighlight">\(\delta P(m_n)/\delta t\)</span> will eventually be integrated to get the function <span class="math notranslate nohighlight">\(P(m_n)\)</span>, so it takes the previous values of <span class="math notranslate nohighlight">\(P\)</span>, a time vector, and two parameters: the initial number of mRNA molecules for the simulation (<span class="math notranslate nohighlight">\(m_o\)</span>) and the current number <span class="math notranslate nohighlight">\(n\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_P</span><span class="p">(</span><span class="n">Ps</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mo</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Ps</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Sm</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dPdt</span> <span class="o">=</span> <span class="n">get_g</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">get_m</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span> <span class="o">-</span> <span class="n">get_m</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">get_g</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dPdt</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">get_m</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_g</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">get_m</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span> <span class="o">-</span> <span class="n">get_m</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mo</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">get_g</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dPdt</span><span class="p">]</span>
</pre></div>
</div>
<p>To visualize multiple possible scenarios, we will want to vary the degradation and production parameters. Rather than changing the two parameters individually, we can vary their ratio, in this case <span class="math notranslate nohighlight">\(\frac{S_m}{d_m}\)</span>. In addition, we can set the maximum number of mRNA molecules to consider. Since most genes only express a limited number of mRNA molecules, this constraint is biologically accurate and speeds up computation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Smdm</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">Sm</span> <span class="o">=</span> <span class="n">Smdm</span><span class="o">*</span><span class="mi">1</span>
<span class="n">dm</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Smdm</span>
<span class="n">max_n</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#maximum number of mRNA molecules to simulate having</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_n</span><span class="p">)</span> <span class="c1">#range of starting mRNA values</span>
<span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_g</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span> <span class="c1">#range of starting g values</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
</pre></div>
</div>
<p>We now iterate through a number of initial numbers of mRNAs and integrate the get_P() function for each condition. We can then plot the results of these functions to see the trajectories.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ps</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="mf">1.</span><span class="p">):</span> <span class="c1">#iterate on mo</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">mo</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">get_P</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="p">[</span><span class="n">mo</span><span class="p">],</span> <span class="n">t</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">mo</span><span class="p">))</span>
        <span class="n">Ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ps</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">Ps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (t/tmax)&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Number of mRNA molecules&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
</pre></div>
</div>
<p>In addition to plotting the raw trajectories, we will want to plot a histogram of the final trajectory positions, which will give us the distribution of mRNA values.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Pull final values for histogram construction</span>
<span class="n">hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">Ps</span><span class="p">]</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">max_n</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Number of mRNA molecules&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Proportion of trajectories&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We ran the simulation for <span class="math notranslate nohighlight">\(\frac{S_m}{d_m}\)</span> values of 0.75, 1, and 1.25. When the value of <span class="math notranslate nohighlight">\(\frac{S_m}{d_m}\)</span> is below one, production occurs faster than degradation so the overall number of mRNA molecules increases and the distribution shifts upward.</p>
<p><img alt="Sm/dm = 0.75" src="../_images/smds75.png" /></p>
<p>At $\frac{S_m}{d_m} = 1, degradation and production rates are perfectly balanced, so the distribution of mRNA molecules remains the same - in this case, perfectly uniform.</p>
<p><img alt="Sm/dm = 1" src="../_images/smds1.png" /></p>
<p>In the case of <span class="math notranslate nohighlight">\(\frac{S_m}{d_m} = 1.25\)</span>, degradation is faster than production, so the overal distribution shifts downward.</p>
<p><img alt="Sm/dm = 1.25" src="../_images/smds125.png" /></p>
<p>In this case, the number of possible initial conditions was small and the model complexity low, so the computational time was not an issue. However, as models incorporate more parameters, the naive protocol used above will start to take a long time. Instead, we can use the <strong>Gillespie algorithm</strong> to speed it up. The Gillespie algorithm has five steps:</p>
<ol class="simple">
<li><p>Write out all possible reactions occuring in the model.</p></li>
<li><p>Randomly sample the exponential probability distribution of possible reactions for a single time step</p></li>
<li><p>Determine based on the probabilities which reaction was most likely. That reaction occured.</p></li>
<li><p>Reinitialize the concentrations and reaction probabilities with the new state</p></li>
<li><p>Iterate steps 2-4 until time t.</p></li>
</ol>
<p>More information on the Gillespie algorithm can be found here {LINK TO PAPER}.</p>
</div>
<div class="section" id="works-cited">
<h2>Works Cited<a class="headerlink" href="#works-cited" title="Permalink to this headline">Â¶</a></h2>
<p>https://www.youtube.com/watch?v=rBYYpPisjEs&amp;ab_channel=OkinawaInstituteofScienceandTechnologyGraduateUniversity%28OIST%29</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./docs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Jupyter Book Community<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>